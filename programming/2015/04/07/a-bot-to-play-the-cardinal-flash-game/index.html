<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />

  <!-- Meta information -->
  <title>
    Beating a Flash game with an AI
  </title>
  <link rel="shortcut icon" href="/favicon.svg" type="image/svg+xml" />

  <!-- CSS -->
  <link rel="stylesheet" href="/css/style.css" />

  <!-- <link rel="canonical" href="https://soreine.dev/programming/2015/04/07/a-bot-to-play-the-cardinal-flash-game/">
  <link rel="alternate" type="application/rss+xml" title="Soreine" href="https://soreine.dev/feed.xml" />
  -->

  <!-- OG attributes -->
  <meta
    name="description"
    content="                        Cardinal is a reflexe-based flash game.            After reading this    article    on Programming a Bot to Play the "Sushi Go Round"..."
  />

  <meta property="og:title" content="Soreine" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://soreine.dev/" />
  <meta property="og:description" content="Soreine's personal website" />
</head>

  <!-- https://instant.page/ -->
  <script src="/scripts/instantpage-3.0.0.js" type="module" defer></script>
  <body>
    <article class="programming">
      <!-- https://github.com/git-no/jekyll-breadcrumbs -->



<nav class="breadcrumbs">
  <ol>
    
    <!--  -->
    
    <!--  -->
    
    <!--  -->
    
    <li>
      <a class="wrapper" href="/">
        <svg
  id="soreine-logo"
  viewBox="0 0 100 60"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    id="mask"
    d="M49.8 24.32C49.8 10.75 61 4.57 76.45 4.57C84.8574 4.57 96.52 2.03 100 0V21.96C100 38.3 86.58 43.98 75.29 43.98C64 43.98 55.49 50.02 49.8 60C49.84 44.32 49.8 33.53 49.8 24.32ZM85.69 36.39C88.37 32.25 89.69 28.35 88.72 23.48C87.57 18.03 83.69 13.64 78.5 11.91C76.74 11.3 75.74 11.2 73.7 11.2C67.15 11.71 61.83 15.13 59.47 20.81C57.87 25.35 58.05 29.63 59.87 33.5C61.31 36.34 63.55 38.63 66.11 40.14C70.48 35.04 82.46 35.55 85.67 36.43L85.69 36.39ZM14.51 36.33C14.01 35.72 13.08 34.2 12.74 33.53C10.88 29.75 10.61 25.16 12.04 21.26C13.62 16.93 17.03 13.49 21.26 11.95C24.13 10.91 27.29 10.75 30.22 11.44C35.54 12.78 39.81 17.03 41.29 22.43C42.66 27.42 41.35 33 37.91 36.9C36.75 38.21 34.5 39.99 34.03 39.96C29.42 35.25 19.48 34.95 14.53 36.3L14.51 36.33Z"
    fill="url(#gradient)"
  />
  <defs>
    <linearGradient
      id="gradient"
      x1="0"
      y1="0"
      x2="100"
      y2="0"
      gradientUnits="userSpaceOnUse"
    >
      <stop id="left-color" offset="0" stop-color="#000000" />
      <stop id="right-color" offset="1" stop-color="#000000" />
    </linearGradient>
  </defs>
</svg>

        <span>Home</span>
      </a>

      
      <!--  -->
      <span class="chevron">
  <svg
    version="1.1"
    id="Capa_1"
    xmlns="http://www.w3.org/2000/svg"
    xmlns:xlink="http://www.w3.org/1999/xlink"
    x="0px"
    y="0px"
    viewBox="0 0 512 512"
    style="enable-background: new 0 0 512 512;"
    xml:space="preserve"
  >
    <g>
      <g>
        <path
          d="M367.954,213.588L160.67,5.872c-7.804-7.819-20.467-7.831-28.284-0.029c-7.819,7.802-7.832,20.465-0.03,28.284
			l207.299,207.731c7.798,7.798,7.798,20.486-0.015,28.299L132.356,477.873c-7.802,7.819-7.789,20.482,0.03,28.284
			c3.903,3.896,9.016,5.843,14.127,5.843c5.125,0,10.25-1.958,14.157-5.873l207.269-207.701
			C391.333,275.032,391.333,236.967,367.954,213.588z"
        />
      </g>
    </g>
    <g></g>
    <g></g>
    <g></g>
    <g></g>
    <g></g>
    <g></g>
    <g></g>
    <g></g>
    <g></g>
    <g></g>
    <g></g>
    <g></g>
    <g></g>
    <g></g>
    <g></g>
  </svg>
</span>

      <!--  -->
      
    </li>

    
    <!--  -->
    
    <!--  -->
    
    <!--  -->
    
    <li>
      <a class="wrapper" href="/programming/"
        ><span>Programming</span></a
      >

      
      <!--  -->
      <span class="chevron">
  <svg
    version="1.1"
    id="Capa_1"
    xmlns="http://www.w3.org/2000/svg"
    xmlns:xlink="http://www.w3.org/1999/xlink"
    x="0px"
    y="0px"
    viewBox="0 0 512 512"
    style="enable-background: new 0 0 512 512;"
    xml:space="preserve"
  >
    <g>
      <g>
        <path
          d="M367.954,213.588L160.67,5.872c-7.804-7.819-20.467-7.831-28.284-0.029c-7.819,7.802-7.832,20.465-0.03,28.284
			l207.299,207.731c7.798,7.798,7.798,20.486-0.015,28.299L132.356,477.873c-7.802,7.819-7.789,20.482,0.03,28.284
			c3.903,3.896,9.016,5.843,14.127,5.843c5.125,0,10.25-1.958,14.157-5.873l207.269-207.701
			C391.333,275.032,391.333,236.967,367.954,213.588z"
        />
      </g>
    </g>
    <g></g>
    <g></g>
    <g></g>
    <g></g>
    <g></g>
    <g></g>
    <g></g>
    <g></g>
    <g></g>
    <g></g>
    <g></g>
    <g></g>
    <g></g>
    <g></g>
    <g></g>
  </svg>
</span>

      <!--  -->
      
    </li>
    
    <!--  -->
    
    <!--  -->
    
    <!--  -->
    
    <!--  -->
    
  </ol>
</nav>


 <div class="post programming">
  
  <h1 class="post-title">Beating a Flash game with an AI</h1>
   <style>
  @media (min-width: 500px) {
    img,
    video {
      max-width: 400px;
    }
  }
</style>

<section>
  <figure>
    <!-- <a title="Cardinal Preview" href="/images/prog/cardinal.mp4"> -->
    <video autoplay muted loop>
      <source src="/images/prog/cardinal.mp4" type="video/mp4" />
    </video>
    <figcaption>Cardinal is a reflexe-based flash game.</figcaption>
    <!-- </a> -->
  </figure>

  <p>
    After reading this
    <a
      href="http://inventwithpython.com/blog/2014/12/17/programming-a-bot-to-play-the-sushi-go-round-flash-game/"
      >article</a
    >
    on <em>Programming a Bot to Play the "Sushi Go Round" Flash Game</em>, I
    wanted to follow the example and make my own Flash game bot. I chose the
    Flash game
    <a href="http://www.newgrounds.com/portal/view/634256"> Cardinal</a> because
    its mechanics are simple: you are prompted with a direction to move (by
    pressing one of the directional keys), one after the other, until you fail
    because of the response time getting shorter. In fact you are a cube
    surrounded by four wall presses, and only one them is absent each time: your
    exit in other words. If you fail to escape in time, the walls crush you. My
    mere human skills escaped death 86 times in a row, whereas my bot did,
    well&hellip; a lot better.
  </p>
</section>
<section>
  <h2>First step - Making the bot play correctly</h2>
  <p>
    Here is the process the bot needs to follow to play the game correctly:
  </p>
  <ul>
    <li>Locate the game area on screen</li>
    <li>Click the Play button so the game starts</li>
    <li>Look for the missing wall in the current setup</li>
    <li>Press the corresponding direction and wait for the next round</li>
  </ul>
  <p>
    To this end, we can take screenshots, look for given images on the screen,
    move the cursor and input keys. These fundamentals actions are made
    available through the
    <a href="https://github.com/asweigart/pyautogui/">pyautogui</a>
    module.
  </p>
  <p>
    Locating the game area on the screen is easy as long as there is a part of
    the game startup screen that is constant. We can just locate that sub-image
    on the whole screen and deduce from that the relative coordinates of the
    game screen and all the elements whose positions are fixed. We can then
    safely move the cursor to the Play button position and click.
  </p>

  <p>
    As the walls' positions are fixed, looking for the missing wall consist in
    taking a screenshot and checking the color value of one pixel from each
    wall's known position. If one of these pixels doesn't match the red color of
    a wall, then the corresponding way is clear. We can then make a move and
    input the appropriate direction!
  </p>

  <figure>
    <a
      class="wrapper"
      title="Gameplay Screenshot"
      href="/images/prog/escaping.png"
    >
      <img alt="Gameplay Screenshot" src="/images/prog/escaping.png" />
    </a>

    <figcaption>The square escaping through the right opening.</figcaption>
  </figure>

  <p>
    After moving, we must wait until the animation of the escaping square is
    over and a new walls setup is displayed. The red square is always put back
    to the center of the screen before every move. So we can watch for that
    moment to come before continuing, by repeatedly taking screenshots and
    checking the presence of the square. However, <em>pyautogui is slow</em> at
    taking screenshots (>100ms). I suspect it is because it saves images in a
    temporary file. So if we don't want to be late for the next round, we must
    time our screenshot so it happens short after the square is back to the
    center. By timing the screenshot well, we can be just in time to make the
    next move. The whole performance of the bot lies on this precise timing.
  </p>

  <p>
    Unfortunately, a screenshot duration varies, so we can only assume it has an
    upper bound. Practically, this means that we must time it so the result is
    available some time after the next round, but still keep some room for
    error. In the worst case, we get a screenshot just
    <em>before</em> the next round and we have to retake a screenshot, which
    takes a lot of time, usually resulting in our time being up. The first
    version of the bot would not go higher than a 80 score.
  </p>
</section>
<section>
  <h2>Second step - Gotta go fast</h2>

  <p>
    In order to improve the bot's performance, we must make faster screenshots.
    I chose a simple way to achieve that. Instead of using the built-in
    screenshot feature of pyautogui, I would create a small C API for taking
    screenshot, using the <a href="http://en.wikipedia.org/wiki/Xlib">Xlib</a>
    library and use this API in Python with the
    <a href="https://docs.python.org/3.4/library/ctypes.html">ctypes</a>
    module. The C code just need to be compiled as a shared library to be loaded
    by Python. The C code does not save pictures in temporary files but store
    them in memory as XImage structures. The only downside is that you now have
    to handle memory management in Python too. But now we can also take
    screenshots of the game region in about 12ms, which is inferior to a frame
    duration! That means enough speed to actually watch repeatedly for the next
    round to come, as we wanted to do in the first place.
  </p>

  <p>
    While the reaction time window shrinks as the game progresses, it seems it
    will not fall under the duration of a frame. This means in practice that
    this second version of the bot is able to play the game indefinetely. I left
    it run for two hours one day, and it was still playing past the 10,000 score
    mark. I had to kill it, sadly, as its power was becoming a threat for
    mankind. It also took away all the fun from this game in the process&hellip;
  </p>

  <figure>
    <a
      class="wrapper"
      title="11K+ High Score"
      href="/images/prog/high-score.png"
    >
      <img alt="11K+ High Score" src="/images/prog/high-score.png" />
    </a>
    <figcaption>
      11,229 High Score achieved with the 2nd version of the bot.
    </figcaption>
  </figure>

  <p>
    Now I need to find a new game &mdash;sigh&mdash;.
  </p>

  <p>
    <a href="https://github.com/Soreine/cardinal-bot/">
      See on GitHub
    </a>
    <img class="github-icon" alt="GitHub" src="/images/GitHub-Mark.svg" />
  </p>
</section>

</div>

    </article>
  </body>
</html>
